<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="读书笔记,javaScript,"><meta name="description" content="Effective JavaScript让自己习惯javaScript1 - 了解你使用的javaScript版本ES5引入的’严格模式’,在js文件连接使用时可能导致问题.  如: 1234567891011&#x2F;&#x2F;file1.js&quot;use strict&quot;;function f()&amp;#123;	&#x2F;&#x2F;...&amp;#125;&#x2F;&#x2F;file2.js no strict-modefunction f()&amp;#123"><meta property="og:type" content="article"><meta property="og:title" content="Effective JavaScript读书笔记"><meta property="og:url" content="http://yoursite.com/2020/04/02/Effective-JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="Kur1ko,"><meta property="og:description" content="Effective JavaScript让自己习惯javaScript1 - 了解你使用的javaScript版本ES5引入的’严格模式’,在js文件连接使用时可能导致问题.  如: 1234567891011&#x2F;&#x2F;file1.js&quot;use strict&quot;;function f()&amp;#123;	&#x2F;&#x2F;...&amp;#125;&#x2F;&#x2F;file2.js no strict-modefunction f()&amp;#123"><meta property="og:image" content="http://yoursite.com/2020/04/02/Effective-JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/D:%5Csummary%5Cfront-end%5Cjavascript%5Cbooks%5Cimages%5C%E5%8E%9F%E5%9E%8B%E5%9B%BE.jpg"><meta property="article:published_time" content="2020-04-02T12:43:38.000Z"><meta property="article:modified_time" content="2020-04-02T12:44:55.443Z"><meta property="article:author" content="kur1ko Sheng"><meta property="article:tag" content="读书笔记,javaScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://yoursite.com/2020/04/02/Effective-JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/D:%5Csummary%5Cfront-end%5Cjavascript%5Cbooks%5Cimages%5C%E5%8E%9F%E5%9E%8B%E5%9B%BE.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"kur1ko"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2020/04/02/Effective-JavaScript读书笔记/"><title>Effective JavaScript读书笔记 | Kur1ko,</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/Kur1ko" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Kur1ko,</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">知其然然后知其所以然,</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-chain"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-list"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/Effective-JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="kur1ko Sheng"><meta itemprop="description" content=""><meta itemprop="image" content="/images/image.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Kur1ko,"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Effective JavaScript读书笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-02T20:43:38+08:00">2020-04-02</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaScript/" itemprop="url" rel="index"><span itemprop="name">javaScript</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">13.8k 字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">54 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Effective-JavaScript"><a href="#Effective-JavaScript" class="headerlink" title="Effective JavaScript"></a>Effective JavaScript</h2><h4 id="让自己习惯javaScript"><a href="#让自己习惯javaScript" class="headerlink" title="让自己习惯javaScript"></a>让自己习惯javaScript</h4><h5 id="1-了解你使用的javaScript版本"><a href="#1-了解你使用的javaScript版本" class="headerlink" title="1 - 了解你使用的javaScript版本"></a>1 - 了解你使用的javaScript版本</h5><p>ES5引入的’严格模式’,在js文件连接使用时可能导致问题.</p><blockquote><p>如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.js</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//file2.js no strict-mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//arguments为方法自带的,在严格模式下重新定义会报错</span></span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">arguments</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个倒过来,非严格模式的在前面,又会导致严格模式文件严格模式无效了.</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>解决方案:</strong></p><ol><li>避免使用严格模式的js文件和不使用严格模式的js文件连接使用.</li><li>通过(function(){…})();的方式包裹自身,在被连接后,都会被独立的解释执行.<strong>缺点是</strong>,这种方法会导致文件的内定义的全局变量,方法等不会被视作全局的.</li></ol><h5 id="2-理解javaScript浮点数"><a href="#2-理解javaScript浮点数" class="headerlink" title="2 - 理解javaScript浮点数"></a>2 - 理解javaScript浮点数</h5><p><strong>tips:</strong></p><ol><li><p>javaScript的数字都是双精度浮点数,即double(64位浮点数).可精确表示-2^53~2^53之间的数.</p><blockquote><p>数字类型 .toString(n);可以把数字转换成对应进制展示 注意数字后要加一个空格</p><p>如 console.log(29 .toString(15)); =&gt; “1e”</p></blockquote></li><li><p>javaScript的整数仅仅是双精度浮点数的一个子集</p></li><li><p>位运算会将数字视为32位有符号整数(会直接舍弃后面的小数位),计算完后把结果转换成浮点数</p><blockquote><p>8.1 | 1 =&gt; 1000.0001100110011001100110011001100110011001100110011 | 1 =&gt; 1000 | 1 =&gt; 1001 =&gt; 1001(浮点数)</p></blockquote></li><li><p>尽量避免使用浮点数运算,可以的话转换成整数计算.如金钱计算都乘以100,以分为单位就不会有小数,就不存在浮点精度误差了.</p></li></ol><h5 id="3-当心隐式类型转换"><a href="#3-当心隐式类型转换" class="headerlink" title="3 - 当心隐式类型转换"></a>3 - 当心隐式类型转换</h5><p>由于javaScript对类型错误极其宽容导致.JavaScript会按照多种多样的自动转换协议将值强制转换为期望的类型.</p><ol><li><p>算数运算符( + - * / % )会尝试把两边都转换成数字(+ 既重载了数字+也重载了字符串加法,具体是数字相加还是字符串相连取决于参数类型, 从左到右)</p><ul><li><p>null在算数运算中会被隐式转换成0</p></li><li><p>未定义的变量会变转换成NaN</p><ul><li><p>如果知道是数字,isNaN可以判断是否是NaN;但如果不是数字,isNaN无法区分.</p><p>如: isNaN(“foo”)=&gt;true ,同理undefined,{},{valueOf:”foo”}都会返回true</p><p><strong>tips:</strong>可以利用NaN是Js中唯一不等于自身的值这个特性, 用 x !== x判断是否为真的NaN</p></li></ul></li></ul></li><li><p>位运算( ~ &amp; ^ | &lt;&lt; &gt;&gt; &gt;&gt;&gt; )会把操作数转换成数字,且会转换成32位整数</p></li><li><p>对象隐式转换toString()方法转换成字符串,valueOf方法转换成数字.除了 “+”外,其他算数运算符会调用valueOf的方法转换成数字计算;位运算也会调用valueOf转换成数字计算;而加法的隐式转换常常会出人意料.所以建议对象有valueOf方法时,同时也要定义toString方法,返回与valueOf值一致的字符串结果.(当然,最好避免使用对象的valueOf方法)(见5)</p><blockquote><p>请留意:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"s"</span>;</span><br><span class="line">x == <span class="string">"s"</span> <span class="comment">//true</span></span><br><span class="line">x === <span class="string">"s"</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"s"</span>) == <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"s"</span>) <span class="comment">//false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"s"</span>) === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"s"</span>) <span class="comment">//false</span></span><br><span class="line">x == <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"s"</span>) <span class="comment">//true</span></span><br><span class="line">x === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"s"</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>真值转换.JavaScript只有7个假值: <strong>false, 0, -0, “”, NaN, null, undefined</strong>.其他都为真值.</p><p>if, || 和 &amp;&amp; 等运算符时,将值转换成真值计算.</p></li><li><p>判断是否为undefined的两种方式</p><ul><li>typeof x === “undefined”</li><li>x === undefined</li></ul></li></ol><h5 id="4-原始类型优于封装对象"><a href="#4-原始类型优于封装对象" class="headerlink" title="4 - 原始类型优于封装对象"></a>4 - 原始类型优于封装对象</h5><p>除对象外,JavaScript有5个原始值类型:布尔值<strong>boolean</strong>,数字<strong>number</strong>,字符串<strong>string</strong>,<strong>null</strong>和<strong>undefined</strong></p><blockquote><p>注意: typeof null会返回object</p><p>布尔值,数字,字符串有对应的包装类型Boolean,Number,String</p></blockquote><p>隐式转换②: 隐式封装.</p><p>举例: “hello”.toUpperCase(); //“HELLO”</p><p>会生成一个新的String对象,调用方法返回结果,且<strong>每次隐式封装都会产生一个新的对象</strong>,</p><p>所以对原始值设置属性是没有任何意义的.</p><blockquote><p>所以:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.someProperty = <span class="number">17</span>;</span><br><span class="line"><span class="string">"hello"</span>.someProperty; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>第一次产生的对象和第二次调用时并不相同,所以第二次会返回undefined</p></blockquote><h5 id="5-避免对混合类型使用-运算符"><a href="#5-避免对混合类型使用-运算符" class="headerlink" title="5 - 避免对混合类型使用 == 运算符"></a>5 - 避免对混合类型使用 == 运算符</h5><p>当两个参数属于同一类型时,使用 == 和 === 运算符没有区别.</p><table><thead><tr><th>参数类型1</th><th>参数类型2</th><th>强制转换</th></tr></thead><tbody><tr><td>null</td><td>undefined</td><td>不转换,总返回true</td></tr><tr><td>null/undefined</td><td>非null/非undefined</td><td>不转换,总返回false</td></tr><tr><td>原始类型string,number,boolean</td><td>Date对象</td><td>原始类型转换成数字,Date对象转换成原始类型(优先尝试toString,再尝试valueOf方法)</td></tr><tr><td>原始类型string,number,boolean</td><td>非Date对象</td><td>原始类型转换成数字,非Date对象转换成原始类型(优先尝试valueOf,再尝试toString方法)</td></tr><tr><td>原始类型string,number,boolean</td><td>原始类型string,number,boolean</td><td>原始类型转换成数字</td></tr></tbody></table><p><strong>解决方案:</strong></p><ol><li>尽量使用 === 运算符</li><li>比较不同类型时,自己定义显示的强制转换方法,让比较的行为更清晰.</li></ol><h5 id="6-了解分号插入的局限"><a href="#6-了解分号插入的局限" class="headerlink" title="6 - 了解分号插入的局限"></a>6 - 了解分号插入的局限</h5><p>分号插入规则:</p><ol><li><p><strong>分号会在 } 标记之前, 一个或多个换行之后, 程序输入的结尾处被插入.</strong></p><p>(即 你可以省略一行后、一个代码块和一段程序结束处的分号)</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> n = +x</span><br><span class="line">	<span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">r</span>) </span>&#123; r  = +r; <span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x+<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>分号仅在随后的输入标记不能解析时插入.</strong></p><blockquote><p>如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b </span><br><span class="line">(f());</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统会判断 a &#x3D; b(f());可以正常解析,所以此处第一行不能省略分号</span><br></pre></td></tr></table></figure></blockquote><p><strong>5个明确有问题的开头字符: ( [ + - /</strong></p><ul><li><strong>解决方案:</strong>在出现这五个开头字符时,显式地在前面加上分号</li></ul><p><strong>javaScript限制产生式(restricted production)不允许两个字符之间出现换行时,会强制插入分号</strong></p><p>包括:</p><ul><li><p>return语句</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#123;&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>throw语句</p></li><li><p>带有显式标签的break或continue语句</p></li><li><p>后置自增或自减运算符</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">++</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a; ++b; <span class="comment">//因为后置++ 就会在a后面强制加上分号</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="3"><li><p><strong>分号不会作为分隔符在for循环空语句的头部被自动插入,空循环体的while循环也需要显式的分号</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, total = <span class="number">1</span>	<span class="comment">//会报错,不会自动插入分号</span></span><br><span class="line">&gt;i &lt; n</span><br><span class="line">&gt;i++)&#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>)</span>&#123; <span class="keyword">while</span>(<span class="literal">true</span>) ; &#125;<span class="comment">//没有这个分号会报错</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="7-视字符串为16位的代码单元序列"><a href="#7-视字符串为16位的代码单元序列" class="headerlink" title="7 - 视字符串为16位的代码单元序列"></a>7 - 视字符串为16位的代码单元序列</h5><p>Unicode为所有文字每个字符都分配了唯一整数,整数介于0和1114111之间,称为代码点.</p><p>Unicode允许多个不同二进制编码的代码点.目前最流行的有UTF-8,UTF-16,UTF-32.</p><p>将代码点与其编码元素一对一映射起来,称为一个代码单元.</p><p>由于历史原因,JavaScript字符串的元素是一个16位的代码单元,字符串属性和方法(如length,charAt,charCodeAt)都是基于代码单元层级,而不是代码点层级.所以每当字符串包含辅助平面的代码点时(即需要用两个代码单元去表示一个代码点时),javascript将每个代码点表示为两个元素而不是一个(一对UTF-16代理对的代码点).<strong>(正则表达式模式也一样有这个问题)</strong></p><blockquote><p>当出现两个代码单元表示一个代码点的时候,length,charAt,charCodeAt等方法在执行时,会出现意想不到的结果.</p><p>而例如sendcodeURI,decodeURI,encodeURIComponent和decodeURIComponent等URI操作函数的ECMAScript库正确的处理了代理对,就不会有问题.</p></blockquote><p><strong>tips:</strong></p><ol><li>使用第三方的库编写可识别代码点的字符串操作.</li><li>每当使用一个含有字符串操作的库时,都要查阅该库文档,看他如何处理代码点的整个范围.</li></ol><hr><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><h5 id="8-尽量少用全局变量"><a href="#8-尽量少用全局变量" class="headerlink" title="8 - 尽量少用全局变量"></a>8 - 尽量少用全局变量</h5><p>定义全局变量会污染共享的公共命名空间,可能导致意外的命名冲突;不利于模块化,因为他会导致程序独立组件之间不必要的耦合.</p><p><strong>tips:</strong></p><ol><li><p>避免声明全局变量,尽量使用局部变量</p></li><li><p>避免对全局对象添加属性</p></li><li><p>使用全局对象来做平台特性检测</p><blockquote><p>如:ES5引入的全局JSON对象(用于读写JSON格式的数据),检测当前环境是否提供了这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">this</span>.JSON)&#123;</span><br><span class="line"> <span class="comment">//如果没有这个对象,就定义一个.</span></span><br><span class="line">	<span class="keyword">this</span>.JSON = &#123;</span><br><span class="line">		parse: ...,</span><br><span class="line">		stringify: ...		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="9-始终声明局部变量"><a href="#9-始终声明局部变量" class="headerlink" title="9 - 始终声明局部变量"></a>9 - 始终声明局部变量</h5><p>不使用var,let,const声明变量,该变量会隐式的转变为全局变量</p><p><strong>tips:</strong></p><ol><li>使用lint工具帮助检查未绑定的变量</li></ol><h5 id="10-避免使用with"><a href="#10-避免使用with" class="headerlink" title="10 - 避免使用with"></a>10 - 避免使用with</h5><blockquote><p>with的简单介绍:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//with 扩展一个语句的作用域链 ES5的严格模式已禁用with</span></span><br><span class="line"><span class="comment">//with 出现的目的是减少变量的长度,减少不必要的指针路径解析运算</span></span><br><span class="line"><span class="keyword">with</span>(expression)&#123;<span class="comment">//将表达式添加到评估语句时使用的作用域链上</span></span><br><span class="line"> statement<span class="comment">//任何语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="keyword">var</span> a, x, y;</span><br><span class="line"><span class="keyword">var</span> r = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">Math</span>)&#123;<span class="comment">//Math被作为默认对象,PI,cos,sin前面不需要添加命名空间</span></span><br><span class="line"> a = PI * r * r;</span><br><span class="line"> x = r * cos(PI);</span><br><span class="line"> y = r * sin(PI / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//with 使程序查找变量时都会先去指定对象中找,那些不属于他的属性查找速度会很慢</span></span><br><span class="line"><span class="comment">//另外,with导致了语义不明的严重问题,如下:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,o</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">with</span>(o)&#123;</span><br><span class="line">     print(x);<span class="comment">//方法f获取的参数x可能取到值,可能为undefined;能取到时,可能在o上,也可能是函数的第一个参数(o中没有x这个属性的话),人力无法预测此处的值</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>tips:</strong></p><ol><li><p>避免使用with语句.不仅性能差,而且有语义问题</p></li><li><p>使用简单的变量名代替重复访问的对象;想要实现with的初衷,可以将局部变量显式的绑定到相关属性上</p><blockquote><p>如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> min = <span class="built_in">Math</span>.min, round = <span class="built_in">Math</span>.round, sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"> <span class="keyword">return</span> min(round(x), sqrt(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="11-熟练掌握闭包"><a href="#11-熟练掌握闭包" class="headerlink" title="11 - 熟练掌握闭包"></a>11 - 熟练掌握闭包</h5><p>JavaScript的函数值包含了比调用他们时执行所需的代码需要的信息以外的更多的信息.</p><p>他们可以获取在其封闭作用域的变量</p><p>那些在其所涵盖的作用域内跟踪变量的函数,称为<strong>闭包</strong>.</p><p>闭包的<strong>三个事实</strong>:</p><p>​ //此处的外部指的是闭包函数的外部</p><ol><li>JavaScript允许你引用当前函数以外定义的变量.=&gt;闭包可以引用定义在其外部作用域的变量</li><li>即使外部函数已经返回,当前函数仍可以引用外部函数所定义的变量.=&gt;闭包比创建他们的函数有更长的生命周期</li><li>闭包可以更新外部变量的值</li></ol><p><strong>warning:</strong>闭包存储的外部变量的引用,而不是值!!!</p><blockquote><p>举例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设一个获取全名的方法</span></span><br><span class="line"><span class="comment">//函数柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLastname</span>(<span class="params">lastname</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">firstname</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;lastname&#125;</span> <span class="subst">$&#123;firstname&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处获取定义了姓的方法</span></span><br><span class="line"><span class="keyword">const</span> getNameStartWithSheng = initLastname(<span class="string">'sheng'</span>);</span><br><span class="line">getNameStartWithSheng(<span class="string">'wei'</span>);<span class="comment">// sheng wei</span></span><br><span class="line">getNameStartWithSheng(<span class="string">'jie'</span>);<span class="comment">// sheng jie</span></span><br><span class="line"><span class="comment">//重新定义一个新的方法...</span></span><br><span class="line"><span class="keyword">const</span> getNameStartWithLi = initLastname(<span class="string">'li'</span>);</span><br></pre></td></tr></table></figure></blockquote><h5 id="12-理解变量声明提升"><a href="#12-理解变量声明提升" class="headerlink" title="12 - 理解变量声明提升"></a>12 - 理解变量声明提升</h5><p><strong>tips:</strong></p><ol><li><p>javaScript隐式地提升声明部分到封闭函数的顶部,而把赋值留在原地;提升方法声明到顶部,而不提升方法调用.</p></li><li><p>在一个作用域中重复声明变量,会被视为单个变量.</p></li><li><p>考虑手动提升局部变量,从而避免混淆.</p></li></ol><blockquote><p>举例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined 		不会出现Uncaught ReferenceError错误</span></span><br><span class="line"><span class="comment">// console.log(b);//打开的话会出现Uncaught ReferenceError: b is not defined</span></span><br><span class="line">c();<span class="comment">//"c" 	不会出现Uncaught ReferenceError错误</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"a"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面的内容等效于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">//console.log(b);</span></span><br><span class="line">c();</span><br><span class="line">a = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure></blockquote><h5 id="13-使用立即调用的函数表达式创建局部作用域"><a href="#13-使用立即调用的函数表达式创建局部作用域" class="headerlink" title="13 - 使用立即调用的函数表达式创建局部作用域"></a>13 - 使用立即调用的函数表达式创建局部作用域</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapElements</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = a.length; i &lt; n; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> a[i];&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wrapped = wrapElements([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]);</span><br><span class="line"><span class="keyword">var</span> f = wrapped[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(f());<span class="comment">//undefined		此处为什么不是10而是undefined?</span></span><br></pre></td></tr></table></figure><p>原因: 闭包是由函数与对其状态即词法环境(lexical environment)的<strong>引用</strong>共同构成.所以上面产生的每一个闭包都绑定了同一个词法环境! 即每个函数都为 return a[5],因为索引越界所以返回undefined</p><p>解决方法:</p><ol><li><p>使用更多的闭包,让回调不再共享同一个词法环境</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &gt;<span class="function"><span class="keyword">function</span> <span class="title">wrapElements</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  &gt;<span class="keyword">var</span> result = [];</span><br><span class="line">  &gt;<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = a.length; i &lt; n; i++)&#123;</span><br><span class="line">  result[i] = returnValue(a[i]);<span class="comment">//此处多一层闭包,强制不共享同一个词法环境</span></span><br><span class="line">  &gt;&#125;</span><br><span class="line">  &gt;<span class="keyword">return</span> result;</span><br><span class="line">  &gt;&#125;</span><br><span class="line">  &gt;<span class="function"><span class="keyword">function</span> <span class="title">returnValue</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">  &gt;&#125;</span><br><span class="line">  &gt;<span class="keyword">var</span> wrapped = wrapElements([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]);</span><br><span class="line">  &gt;<span class="keyword">var</span> f = wrapped[<span class="number">0</span>];</span><br><span class="line">  &gt;<span class="built_in">console</span>.log(f());<span class="comment">//10</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>创建一个嵌套函数并立即调用它来创建一个局部作用域</p><p><strong>warnings:</strong>要当心函数中包裹代码块导致代码块的微妙变化.</p><ul><li>代码块不能包含break; continue语句.是不合法的</li><li>代码块如果引用了this或特别的arguments变量,这种方式会改变他们的含义!</li></ul><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapElements</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> result = [];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = a.length; i &lt; n; i++)&#123;</span><br><span class="line"> 	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 		<span class="keyword">var</span> j = i;</span><br><span class="line"> 		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> a[j];&#125;;</span><br><span class="line"> 	&#125;)();</span><br><span class="line">     <span class="comment">//此处也可以是如下形式,将局部变量作为实参传入</span></span><br><span class="line">     <span class="comment">//(function(j)&#123;</span></span><br><span class="line"> 	<span class="comment">//	result[i] = function()&#123;return a[j];&#125;;</span></span><br><span class="line"> 	<span class="comment">//&#125;)(i);</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wrapped = wrapElements([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]);</span><br><span class="line"><span class="keyword">var</span> f = wrapped[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(f());<span class="comment">//10</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>使用ES6 let关键字,绑定块作用域</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapElements</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> result = [];</span><br><span class="line"> <span class="comment">//仅仅是此处声明i时使用let.因为let不会提升变量的声明.每个闭包都绑定了块作用域的变量</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, n = a.length; i &lt; n; i++)&#123;</span><br><span class="line">     result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> a[i];&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wrapped = wrapElements([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]);</span><br><span class="line"><span class="keyword">var</span> f = wrapped[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(f());<span class="comment">//10</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="14-当心命名函数表达式笨拙的作用域"><a href="#14-当心命名函数表达式笨拙的作用域" class="headerlink" title="14 - 当心命名函数表达式笨拙的作用域"></a>14 - 当心命名函数表达式笨拙的作用域</h5><p><strong>缺陷1:</strong></p><p>命名函数表达式,即 function xxx(){};</p><p>常用于调试.在对Error对象的栈跟踪功能中,函数表达式的名称通常作为其入口使用.但是命名函数表达式是作用域和兼容性问题臭名昭著的来源.</p><p>ES3中,JavaScript引擎被要求将命名函数表达式的作用域表示为一个对象,这个对象只有单个属性,将函数名和函数自身绑定起来,但是这个对象也继承了Object.prototype的属性.因此,就把Object.prototype中的所有属性引入了作用域.</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">constructor</span> = function()&#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">constructor</span>();</span><br><span class="line">&#125;;</span><br><span class="line">f();//&#123;&#125; (<span class="keyword">in</span> ES3 environments)</span><br><span class="line"><span class="comment">//因为命名函数表达式在其作用域内集成了Object的构造函数</span></span><br><span class="line">这种情况删除函数表达式名即可</span><br><span class="line">即</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">constructor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//存在:一些不符合标准的js环境中,即使删除了函数表达式名,调用f()依旧会返回一个空对象.</span><br></pre></td></tr></table></figure></blockquote><p><strong>避免方式:</strong></p><p>在任何时候都避免对Object.prototype中添加属性,以及使用与Object.prototype属性同名的局部变量.</p><p><strong>缺陷2:</strong></p><p>对命名函数表达式的声明进行提升.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一些不符合标准的环境中</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">17</span>;&#125;;</span><br><span class="line">g();<span class="comment">//17</span></span><br><span class="line"><span class="comment">//甚至这两个对象是两个不同的对象,导致了不必要的内存分配</span></span><br></pre></td></tr></table></figure><p><strong>解决办法:</strong></p><p>创建一个与函数表达式同名的局部变量并赋值为null;//确保重复的函数会被垃圾回收.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">17</span>;&#125;;</span><br><span class="line"><span class="keyword">var</span> g = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><ol><li><p>在Error对象和调试器中使用命名函数表达式改进栈跟踪.</p></li><li><p>在ES3和有问题的js环境中谨记函数表达式作用域会被Object.prototype污染.<strong>//ES5中已解决bug</strong></p></li><li><p>谨记在错误百出的js环境中会提升命名函数表达式声明,导致重复存储</p></li><li><p>考虑避免使用命名函数表达式或在发布前删除函数名</p><p><strong>=&gt; 如果代码发布到正确实现的ES5环境,就不必担心上述问题.</strong></p></li></ol><h5 id="15-当心局部块函数声明笨拙的作用域"><a href="#15-当心局部块函数声明笨拙的作用域" class="headerlink" title="15 - 当心局部块函数声明笨拙的作用域"></a>15 - 当心局部块函数声明笨拙的作用域</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">"global"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">"local"</span>;&#125;;</span><br><span class="line">        result.push(f());</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(f());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">true</span>);<span class="comment">//?</span></span><br><span class="line">test(<span class="literal">false</span>);<span class="comment">//?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在ES5及以前,不存在块级作用域,test内部的f()作用域是整个函数.</span></span><br><span class="line"><span class="comment">//因此,结果为["local","local"]和"["local"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在ES6中,存在块级作用域.</span></span><br><span class="line"><span class="comment">//如上代码在执行到result.push(f())时,会报f is not a function的错</span></span><br><span class="line"><span class="comment">//将内部修改为 let f = function()&#123;return "local";&#125;;则返回["local","global"]和"["global"]</span></span><br></pre></td></tr></table></figure><h5 id="16-避免使用eval创建局部变量"><a href="#16-避免使用eval创建局部变量" class="headerlink" title="16 - 避免使用eval创建局部变量"></a>16 - 避免使用eval创建局部变量</h5><p>如: eval(“var y = ‘hello’; “);这一句在被调用后才会执行,将y变量加入到作用域.</p><p><strong>tips:</strong></p><ol><li><p>避免使用eval函数创建的变量污染调用者的作用域.</p></li><li><p>如果eval函数代码可能创建全局变量,可以将此调用封装到嵌套的函数中,以防止作用域污染.</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">eval</span>(src);&#125;)();</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">"var y = 'local';"</span>); <span class="comment">//"global"</span></span><br><span class="line">test(<span class="string">"var z = 'local';"</span>); <span class="comment">//"global"</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="remain-learning-17-间接调用eval函数优于直接调用"><a href="#remain-learning-17-间接调用eval函数优于直接调用" class="headerlink" title="(remain learning)17 - 间接调用eval函数优于直接调用"></a>(remain learning)17 - 间接调用eval函数优于直接调用</h5><p>eval函数不仅仅是一个函数,还可以访问调用它时的整个作用域.</p><p>尽可能使用间接的方式调用eval函数.</p><p>两种调用eval的方式:</p><ol><li><p>直接调用</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="string">"global"</span>;</span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;<span class="keyword">var</span> x = <span class="string">"local"</span>;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"x"</span>);<span class="comment">//direct eval</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;test(); <span class="comment">//"local",此时调用时具有完全访问局部作用域的权限</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>间接调用</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="string">"global"</span>;</span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;<span class="keyword">var</span> x = <span class="string">"local"</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> f = <span class="built_in">eval</span>;<span class="comment">//绑定eval函数到另一个变量名</span></span><br><span class="line">&gt;<span class="keyword">return</span> f(<span class="string">"x"</span>);<span class="comment">//通过变量名调用函数,会使代码失去对局部作用域访问的能力</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;test();<span class="comment">//"global"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="number">0</span>,<span class="built_in">eval</span>)(src);</span><br><span class="line">&gt;<span class="comment">//(,)表达式序列运算符总会返回最后一项,所以前面无论是0还是其他字面量都没关系,都会返回eval,整个表达式被视为间接调用eval函数</span></span><br><span class="line">&gt;<span class="comment">//直接使用evel(src);左侧被视为一个引用</span></span><br><span class="line">&gt;<span class="comment">//(0,eval)(src);左侧被视为一个值</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><h4 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h4><h5 id="18-理解函数调用、方法调用及构造函数调用之间的不同"><a href="#18-理解函数调用、方法调用及构造函数调用之间的不同" class="headerlink" title="18 - 理解函数调用、方法调用及构造函数调用之间的不同"></a>18 - 理解函数调用、方法调用及构造函数调用之间的不同</h5><p>在javaScript中,他们只是单个构造对象的三种不同的使用模式</p><p>函数调用</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"hello, "</span> + username;</span><br><span class="line">&#125;</span><br><span class="line">hello(<span class="string">"keyser Soze"</span>);<span class="comment">//"hello, keyser Soze"</span></span><br></pre></td></tr></table></figure></blockquote><p>方法调用</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"hello, "</span> + <span class="keyword">this</span>.username;</span><br><span class="line"> &#125;,</span><br><span class="line"> username: <span class="string">"hans Gruber"</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.hello();<span class="comment">//"hello, hans Gruber"//方法调用需要对象来调用,直接调用就时函数调用了</span></span><br><span class="line"><span class="comment">//注意以下情况</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line"> hello: obj.hello,</span><br><span class="line"> username: <span class="string">"Boo Radley"</span></span><br><span class="line">&#125;;</span><br><span class="line">obj2.hello();<span class="comment">//"hello, Boo Radley"</span></span><br><span class="line"><span class="comment">//方法调用中,由调用表达式自身来确定this变量的绑定. 调用表达式为obj2.hello()所以this指向obj2,而不是obj</span></span><br><span class="line"><span class="comment">//此处先略过call,bind,apply</span></span><br></pre></td></tr></table></figure></blockquote><p>构造函数调用</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, password</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> User(<span class="string">"sfalken"</span>,<span class="string">"xxx"</span>);<span class="comment">//构造函数需要通过new运算符调用</span></span><br><span class="line">u.name;<span class="comment">//"sfalken"</span></span><br><span class="line"><span class="comment">//构造函数调用一个全新的对象作为this变量的值,并隐式地返回这个新对象作为调用的结果,即 产生的新对象传递给了u.构造函数的主要职责时初始化该新对象.</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="19-熟练掌握高阶函数"><a href="#19-熟练掌握高阶函数" class="headerlink" title="19 - 熟练掌握高阶函数"></a>19 - 熟练掌握高阶函数</h5><p>高阶函数: 将函数作为参数或返回值的函数.</p><p>学会发现可以被高阶函数取代的常见编码模式.</p><blockquote><p>举例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>].sort(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x &lt; y)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">if</span>(x &gt; y)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);<span class="comment">//1,1,3,4,5,9</span></span><br><span class="line"><span class="comment">//此处定义了一个判断数字大小的方法作为参数传递</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="20-使用call方法自定义接收者来调用方法"><a href="#20-使用call方法自定义接收者来调用方法" class="headerlink" title="20 - 使用call方法自定义接收者来调用方法"></a>20 - 使用call方法自定义接收者来调用方法</h5><p>func.call(thisArg [, arg1[,arg2…]])</p><p>第一个参数显式地提供了接收者对象.</p><p><strong>tips:</strong></p><ol><li><p>使用call方法自定义接收者来调用函数</p></li><li><p>使用call方法可以调用在给定的对象中不存在的方法</p></li><li><p>使用call方法定义高阶函数允许使用者给回调函数指定接收者</p><blockquote><p>举例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> table = &#123;</span><br><span class="line">&gt;entries: [],</span><br><span class="line">&gt;addEntry: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.entries.push(&#123;<span class="attr">key</span>:key, <span class="attr">value</span>: value&#125;);</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;forEach: <span class="function"><span class="keyword">function</span>(<span class="params">f, thisArg</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> entries = <span class="keyword">this</span>.entries;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = entries.length; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> entry = entries[i];</span><br><span class="line">    <span class="comment">//回调函数f,并指定接收者为thisArg</span></span><br><span class="line">    f.call(thisArg, entry.key, entry.value, i);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//如table2赋值table1的内容</span></span><br><span class="line">&gt;table1.forEach(table2.addEntry, table2);</span><br><span class="line">&gt;<span class="comment">//如果call的第一个参数为null或undefined,则内部this指向window</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h6><p>call和apply的区别是参数提供的方式</p><p>bind与call,apply的区别是,bind只绑定,而call和apply会立即调用</p></li></ol><h5 id="21-使用apply-方法通过不同数量的参数调用函数"><a href="#21-使用apply-方法通过不同数量的参数调用函数" class="headerlink" title="21- 使用apply 方法通过不同数量的参数调用函数"></a>21- 使用apply 方法通过不同数量的参数调用函数</h5><p>func.apply(thisArg, [argsArray])</p><p>apply可以处理任意数量的参数</p><p>apply与call十分类似,区别就是参数为参数数组传入,而call从第二个参数开始有0至多个参数</p><h5 id="22-使用arguments创建可变参数的函数"><a href="#22-使用arguments创建可变参数的函数" class="headerlink" title="22 - 使用arguments创建可变参数的函数"></a>22 - 使用arguments创建可变参数的函数</h5><p>JavaScript给给个函数都隐式提供了一个名为arguments的局部变量.可以用索引获取方法的每个实参(arguments对象并不是一个数组),并且该对象还有一个length属性来指示参数的个数.</p><p><strong>tips:</strong></p><ol><li>使用隐式的arguments对象实现可变参数的函数</li><li>考虑对可变参数的函数提供一个额外的固定元数的版本,从而使使用者无需借助apply方法</li></ol><h5 id="23-永远不要修改arguments对象"><a href="#23-永远不要修改arguments对象" class="headerlink" title="23 - 永远不要修改arguments对象"></a>23 - 永远不要修改arguments对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callMethod</span>(<span class="params">obj, method</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> shift = [].shift;</span><br><span class="line">    shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> obj[method].apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">callMethod(obj, <span class="string">"add"</span>, <span class="number">17</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">//error: cannot read property "apply" of undefined</span></span><br><span class="line"><span class="comment">//arguments对象并不是函数参数的副本.所有命名参数都是arguments对象中对应索引的别名</span></span><br><span class="line"><span class="comment">//=&gt; 参数obj依旧是arguments[0]的别名,method依旧是arguments[1]的别名</span></span><br><span class="line"><span class="comment">//因此此处调用的不是obj['add']而是17['25']</span></span><br><span class="line"><span class="comment">//=&gt;arguments对象和函数的命名参数之间的关系非常脆弱.所以不建议修改arguments对象</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对比严格模式下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line">	<span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="string">"modified"</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>],x);<span class="comment">//modified unmodified</span></span><br><span class="line">	<span class="keyword">return</span> x === <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nostrict</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="string">"modified"</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>],x);<span class="comment">//modified modified</span></span><br><span class="line">	<span class="keyword">return</span> x === <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(strict(<span class="string">"unmodified"</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(nostrict(<span class="string">"unmodified"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//非严格模式下,arguments和函数命名参数都修改了,而严格模式下,命名参数没被修改</span></span><br><span class="line"><span class="comment">//严格模式下,不支持对其arguments对象取别名,即 此处x不是arguments[0].所以严格模式下返回的结果为false</span></span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><p>使用[].slice.call(arguments)将arguments复制到一个真正的数组中再进行修改.</p><h5 id="24-使用变量保存arguments的引用"><a href="#24-使用变量保存arguments的引用" class="headerlink" title="24 - 使用变量保存arguments的引用"></a>24 - 使用变量保存arguments的引用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">values</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span>, n = <span class="built_in">arguments</span>.length;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		hasNext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i &lt; n;</span><br><span class="line">		&#125;,</span><br><span class="line">		next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &gt;= n )&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">arguments</span>[i++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = values(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//console.log(it);</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//原因是一个新的arguments变量被隐式地绑定到每个函数体内</span></span><br><span class="line"><span class="comment">//it对象的next方法有自己的arguments对象,且为null,打印时就成了undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方案:</span></span><br><span class="line"><span class="comment">//在我们需要的arguments对象的作用域中,使用一个变量去绑定,引用这个变量即可</span></span><br><span class="line"><span class="comment">//?感觉可以理解为闭包?访问作用域内的参数,因为it的方法中有本地的arguments对象了,所以会优先使用本地的arguments,而此处添加一个引用,在it的方法中不再拥有,就不会出问题了.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">values</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">+	<span class="keyword">var</span> i = <span class="number">0</span>, n = <span class="built_in">arguments</span>.length, a = <span class="built_in">arguments</span>;</span><br><span class="line">-   <span class="keyword">var</span> i = <span class="number">0</span>, n = <span class="built_in">arguments</span>.length;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		hasNext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i &lt; n;</span><br><span class="line">		&#125;,</span><br><span class="line">		next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &gt;= n )&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">+			<span class="keyword">return</span> a[i++];</span><br><span class="line">-			<span class="keyword">return</span> <span class="built_in">arguments</span>[i++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = values(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//console.log(it);</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><ol><li>当引用arguments时当心函数嵌套层级</li><li>绑定一个明确作用域的引用到arguments变量,从而可以在嵌套的函数中引用他</li></ol><h5 id="25-使用bind方法提取具有确定接收者的方法"><a href="#25-使用bind方法提取具有确定接收者的方法" class="headerlink" title="25 - 使用bind方法提取具有确定接收者的方法"></a>25 - 使用bind方法提取具有确定接收者的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = &#123;</span><br><span class="line">	entries:[],</span><br><span class="line">	add: <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);<span class="comment">//Arguments(3) ["867", 0, Array(3), callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">		<span class="keyword">this</span>.entries.push(s);</span><br><span class="line">	&#125;,</span><br><span class="line">	concat:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.entries.join(<span class="string">""</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> source = [<span class="string">"867"</span>,<span class="string">"-"</span>,<span class="string">"5309"</span>];</span><br><span class="line"></span><br><span class="line">source.forEach(buffer.add);<span class="comment">// Cannot read property 'push' of undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(buffer.concat());</span><br><span class="line"></span><br><span class="line"><span class="comment">//原因:此处buffer.add的接收者不是buffer对象</span></span><br><span class="line"><span class="comment">//forEach方法的实现使用全局对象作为默认的接收者,所以此处传递给了全局对象,全局对象没有entries,所以报错</span></span><br><span class="line"><span class="comment">//arr.forEach(callback(currentValue [, index [, array]])[, thisArg]);</span></span><br><span class="line"><span class="comment">//thisArg为null或者undefined时,this都指向全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方案:</span></span><br><span class="line"><span class="comment">//1.forEach提供了绑定接收者的参数</span></span><br><span class="line">source.forEach(buffer.add, buffer);</span><br><span class="line"><span class="comment">//2.bind方法绑定this到buffer上</span></span><br><span class="line">source.forEach(buffer.add.bind(buffer));</span><br></pre></td></tr></table></figure><h5 id="26-使用bind方法实现函数柯里化"><a href="#26-使用bind方法实现函数柯里化" class="headerlink" title="26 - 使用bind方法实现函数柯里化"></a>26 - 使用bind方法实现函数柯里化</h5><p>函数柯里化: 创建一个固定需求参数子集的委托函数,即只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数(11 - 数量掌握闭包里有)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleURL</span>(<span class="params">protocol, domain, path</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> protocol + <span class="string">"://"</span> + domain + <span class="string">"/"</span> + path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> urls = paths.map(<span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> simpleURL(<span class="string">"http"</span>, siteDomain, path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = paths.map(simpleURL.bind(<span class="literal">null</span>, <span class="string">"http"</span>, siteDomain));</span><br><span class="line"><span class="comment">//因为不需要引用this变量,所以bind的第一个参数可以是任何值,使用null或undefined为习惯用法</span></span><br></pre></td></tr></table></figure><h5 id="27-使用闭包而不是字符串来封装代码-现在ES6有块级作用域了-感觉答案更显而易见了"><a href="#27-使用闭包而不是字符串来封装代码-现在ES6有块级作用域了-感觉答案更显而易见了" class="headerlink" title="27 - 使用闭包而不是字符串来封装代码(?现在ES6有块级作用域了,感觉答案更显而易见了?)"></a>27 - 使用闭包而不是字符串来封装代码(?现在ES6有块级作用域了,感觉答案更显而易见了?)</h5><p>//这里说的字符串来封装代码使用的是eval(str)的方法来执行</p><p>不使用字符串的原因:</p><ol><li>eval内的代码要执行到这一行才会生效,使用的参数可能跟想象中的有差异.</li><li>高性能引擎很难优化eval字符串里面的代码</li></ol><p><strong>tips:</strong></p><ol><li>当将字符串传递给eval函数以执行他们的API时,绝不要在字符串内包含局部变量的引用</li><li>接受函数调用的API优于使用eval函数执行字符串的API</li></ol><h5 id="28-不要信赖函数对象的toString方法"><a href="#28-不要信赖函数对象的toString方法" class="headerlink" title="28 - 不要信赖函数对象的toString方法"></a>28 - 不要信赖函数对象的toString方法</h5><p>//此处指的是用toString试图获取函数的源代码</p><p><strong>tips:</strong></p><ol><li>当调用函数的toString方法时,并没有要求js引擎能够精确地获取到函数的源代码</li><li>由于在不同引擎下调用的toString方法的结果可能不同,所以绝不要信赖函数toString获得的源代码的详细细节.</li><li>toString方法的执行结果并不会暴露存储在闭包中的局部变量值.</li><li>通常情况下,避免使用函数对象的toString方法</li></ol><h5 id="remain-learning-29-避免使用非标准的栈检查属性"><a href="#remain-learning-29-避免使用非标准的栈检查属性" class="headerlink" title="(remain learning)29 - 避免使用非标准的栈检查属性"></a>(remain learning)29 - 避免使用非标准的栈检查属性</h5><p>许多javaScript环境提供检查调用栈的功能.每个arguments对象都含有两个额外的属性,<strong>arguments.callee</strong>(除了允许匿名函数递归地引用自身之外,没有用途)和<strong>arguments.caller</strong>(这个属性不可靠,大多数环境已移除),前者指向使用该arguments对象被调用的函数,后者指向调用该arguments对象的函数.</p><p><strong>tips:</strong></p><ol><li>避免使用非标准的arguments.caller和arguments.callee属性,因为他们不具有良好的移植性.</li><li>避免使用非标准的函数对象caller属性,因为在包含全部栈信息方面,是不可靠的.</li><li>最好的策略是使用交互式的调试器.</li></ol><hr><h4 id="对象和原型"><a href="#对象和原型" class="headerlink" title="对象和原型"></a>对象和原型</h4><h5 id="30-理解prototype-getPrototypeOf和-proto-之间的不同"><a href="#30-理解prototype-getPrototypeOf和-proto-之间的不同" class="headerlink" title="30 - 理解prototype, getPrototypeOf和__proto__之间的不同"></a>30 - 理解prototype, getPrototypeOf和__proto__之间的不同</h5><p>User.prototype指向由new User()创建的对象的原型</p><p>Object.getPrototypeOf(user)是ES5中用来获得user对象的原型对象的标准方法</p><p>user.__proto__是获取user对象的原型对象的非标准方法</p><p><img src="/2020/04/02/Effective-JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/D:%5Csummary%5Cfront-end%5Cjavascript%5Cbooks%5Cimages%5C%E5%8E%9F%E5%9E%8B%E5%9B%BE.jpg" alt></p><p>User构造函数有一个默认的prototype属性指向原型对象.</p><p>由new User()创建的user对象继承User原型对象.当查找user对象属性时,如果user没有,就会到他继承的User原型对象中去找.</p><p>ES5提供了Object.getPrototypeOf()的方法去获取对象的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(user) === User.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>一些环境提供了非标准的方法获取对象的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.__proto__ === User.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="31-使用Object-getPrototypeOf函数-而不要使用-proto-属性"><a href="#31-使用Object-getPrototypeOf函数-而不要使用-proto-属性" class="headerlink" title="31 - 使用Object.getPrototypeOf函数,而不要使用__proto__属性"></a>31 - 使用Object.getPrototypeOf函数,而不要使用__proto__属性</h5><h5 id="32-始终不要修改-proto-属性"><a href="#32-始终不要修改-proto-属性" class="headerlink" title="32 - 始终不要修改__proto__属性"></a>32 - 始终不要修改__proto__属性</h5><p>原因:</p><ol><li>__proto__属性很特殊,他提供了Object.getPrototypeOf方法不具备的修改对象原型链接的能力.因为并不是所有平台都支持改变对象原型的特性,所以<strong>有可移植性的问题</strong></li><li><strong>性能原因</strong>.因为现代的js引擎都深度优化了获取和设置对象属性的行为,更改对象的内部结构(如添加或删除该对象或其原型链中对象的属性),将会使一些优化失效.修改__proto__属性实际上改变了继承结构本身,可能是最具破坏性的修改.会<strong>导致更多的优化失效.</strong></li><li><strong>为了保持行为的可预测性</strong>.修改对象的原型链会交换对象的整个继承层次结构.</li></ol><p><strong>tips:</strong></p><ol><li>使用Object.create函数给新对象设置自定义的原型.</li></ol><h5 id="33-使构造函数与new操作符无关-ES6引入了class-这部分内容应该过时了"><a href="#33-使构造函数与new操作符无关-ES6引入了class-这部分内容应该过时了" class="headerlink" title="33 - 使构造函数与new操作符无关(ES6引入了class,这部分内容应该过时了)"></a>33 - 使构造函数与new操作符无关(ES6引入了class,这部分内容应该过时了)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用构造函数时,忘记使用new关键字</span></span><br><span class="line"><span class="comment">//这样函数的接收者将是全局对象</span></span><br><span class="line"><span class="comment">//会灾难性地创建全局变量,如果已存在则会修改其值</span></span><br><span class="line"><span class="keyword">var</span> u = User(<span class="string">"name"</span>, <span class="string">"password"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, password</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//"use strict";</span></span><br><span class="line">    <span class="comment">//如果使用严格模式, 则this.name = name;这一行会报错</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=&gt;可以修改为以下方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, password</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span> <span class="keyword">instanceof</span> User ? <span class="keyword">this</span> : <span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line">    self.name = name;</span><br><span class="line">    self.password = password;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="34-在原型中存储方法"><a href="#34-在原型中存储方法" class="headerlink" title="34 - 在原型中存储方法"></a>34 - 在原型中存储方法</h5><p><strong>好处:</strong></p><p>​ 将方法存储在原型中,使其可以被所有的实例使用,<strong>减少了占用的内存</strong>.现代的js引擎深度优化了原型查找,所以相对于把方法冗余地写在实例对象中,并不一定能保证在查找速度上有明显的提升.</p><h5 id="35-使用闭包存储私有数据"><a href="#35-使用闭包存储私有数据" class="headerlink" title="35 - 使用闭包存储私有数据"></a>35 - 使用闭包存储私有数据</h5><p>闭包时一种简朴的数据结构.他们将数据存储到封闭的变量中而不提供对这些变量的直接访问.获取闭包内部结构的唯一方式是该函数显式地提供获取它的途径.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该实现以变量的方式来引用name和passwordHash变量,而不是this属性的方式</span></span><br><span class="line"><span class="comment">//此时User的实例中不会包含任何实例属性,因此外部的代码不能直接访问User的实例的name和passwordHash变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, passwordHash</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">`[User <span class="subst">$&#123;name&#125;</span>]`</span>;&#125;</span><br><span class="line">    <span class="keyword">this</span>.checkPassword = <span class="function"><span class="keyword">function</span>(<span class="params">password</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash(password) === passwordHash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺点:</span></span><br><span class="line"><span class="comment">//为了使构造函数中的变量在使用他们的方法的作用域内,那些方法必须置于实例对象中</span></span><br><span class="line"><span class="comment">//即不能用继承的方式去减少占用内存了.因为对象内部根本没有name和passwordHash这两个属性了.仅实例中定义的方法能访问这两个变量</span></span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><ol><li>闭包的变量是私有的,只能通过局部的引用获取</li><li>将局部变量作为私有属性从而通过方法实现信息隐藏.</li></ol><h5 id="36-只将实例状态存储在实例对象中"><a href="#36-只将实例状态存储在实例对象中" class="headerlink" title="36 - 只将实例状态存储在实例对象中"></a>36 - 只将实例状态存储在实例对象中</h5><p>有状态的数据可以存储在原型中,只要你真的想要共享它.</p><p>一般情况下,原型对象中共享方法,而每个实例的状态存储在各自的实例对象中.</p><h5 id="37-认识到this变量的隐式绑定问题"><a href="#37-认识到this变量的隐式绑定问题" class="headerlink" title="37 - 认识到this变量的隐式绑定问题"></a>37 - 认识到this变量的隐式绑定问题</h5><p><strong>tips:</strong></p><ol><li>this变量的作用域总是由其最近的封闭函数所确定.</li><li>使用一个局部变量(通常为self,me或that)绑定this,然后在内部函数中使用.</li></ol><h5 id="38-在子类的构造函数中调用父类的构造函数-ES6引入了class-这部分内容应该过时了"><a href="#38-在子类的构造函数中调用父类的构造函数-ES6引入了class-这部分内容应该过时了" class="headerlink" title="38 - 在子类的构造函数中调用父类的构造函数(ES6引入了class,这部分内容应该过时了)"></a>38 - 在子类的构造函数中调用父类的构造函数(ES6引入了class,这部分内容应该过时了)</h5><p><strong>tips:</strong></p><ol><li>在子类的构造函数中,显示传入this作为显示的接收者调用父类的构造函数</li><li>使用Object.create函数来构造子类的原型对象以避免调用父类的构造函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br></pre></td></tr></table></figure><h5 id="39-不要重用父类的属性名"><a href="#39-不要重用父类的属性名" class="headerlink" title="39 - 不要重用父类的属性名"></a>39 - 不要重用父类的属性名</h5><h5 id="40-避免继承标准类"><a href="#40-避免继承标准类" class="headerlink" title="40 - 避免继承标准类"></a>40 - 避免继承标准类</h5><p>ECMAScript标准库内的类定义了很多特殊的行为,很难写出行为正确的子类.</p><p>ECMAScript定义的完整的[[Class]]属性值集合:</p><table><thead><tr><th>[[Class]]</th><th>Construction</th></tr></thead><tbody><tr><td>“Array”</td><td>new Array(…), […]</td></tr><tr><td>“Boolean”</td><td>new Boolean(…)</td></tr><tr><td>“Date”</td><td>new Date(…)</td></tr><tr><td>“Error”</td><td>new Error(…), new EvalError(…), new RangeError(…), new ReferenceError(…), new SyntaxError(…), new TypeError(…), new URIError(…)</td></tr><tr><td>“Function”</td><td>new Function(…), function (…){…}</td></tr><tr><td>“JSON”</td><td>JSON</td></tr><tr><td>“Math”</td><td>Math</td></tr><tr><td>“Number”</td><td>new Number(…)</td></tr><tr><td>“Object”</td><td>new Object(…), {…}, new MyClass(…)</td></tr><tr><td>“RegExp”</td><td>new RegExp(…), /…/</td></tr><tr><td>“String”</td><td>new String(…)</td></tr></tbody></table><p>通过右侧的构造函数创建的才能有[[Class]]这个内部属性.</p><p>因为[[Class]]属性及其他特殊的内部属性导致继承这些类总会有问题,因此,最好<strong>避免继承: Array, Boolean, Date, Function, Number, RegExp或 String.</strong></p><p>Math对象所有属性和方法都是静态的,可对其作拓展.</p><p>JSON对象只有parse()和stringify()两个方法,除了这两个方法外,对象本身并无其他作用,也不能被调用或作为构造函数调用.</p><p>Error, Object常被继承.</p><p><strong>tips:</strong></p><ol><li>使用属性委托优于继承标准类.</li></ol><h5 id="41-将原型视为实现细节"><a href="#41-将原型视为实现细节" class="headerlink" title="41 - 将原型视为实现细节"></a>41 - 将原型视为实现细节</h5><p>因为对一个对象的操作,并不需要在意属性或方法是在原型继承结构的那个位置,修改原型上的方法/属性,将会影响依赖这个原型的对象.</p><p><strong>tips:</strong></p><ol><li>对象是接口,原型是实现(即原型实现了实际的功能, 我们调用继承这个原型的对象,这个对象就相当于一个接口)</li><li>避免检查你无法控制的对象的原型结构</li><li>避免检查实现在你无法控制的对象内部的属性</li></ol><h5 id="42-避免使用轻率的猴子补丁"><a href="#42-避免使用轻率的猴子补丁" class="headerlink" title="42 - 避免使用轻率的猴子补丁"></a>42 - 避免使用轻率的猴子补丁</h5><p><strong>猴子补丁(monkey-patching):</strong> 对象共享原型,所以每一个对象都可以增加、删除或修改原型的属性,这个操作被称为猴子补丁.</p><p><strong>使用场景:</strong>polyfill.即在某些js环境中,使用旧的方式实现新的API.</p><p><strong>举例:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先判断是否有这个方法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.map !== <span class="string">"function"</span>)&#123;</span><br><span class="line">    <span class="comment">//没有这个方法的话,为之定义</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f, thisArg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = <span class="keyword">this</span>.length; i &lt; n; i++)&#123;</span><br><span class="line">            result[i] = f.call(thisArg, <span class="keyword">this</span>[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><ol><li><p>避免轻率地使用猴子补丁.</p></li><li><p><strong>记录程序库所执行的所有猴子补丁.</strong></p></li><li><p>考虑通过将修改置于一个导出函数中,使猴子补丁称为可选(即可以选择执行这个方法,也可选择执行其他的,而不是直接打在原型上)</p><blockquote><p>如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//置于函数中,用户可以选择调用该函数或忽略</span></span><br><span class="line">&gt;<span class="comment">//如果忽略,Array原型上就不具有该方法,调用,则具有</span></span><br><span class="line">&gt;<span class="comment">//这样就不会有多处定义导致冲突的问题</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">addArrayMethods</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;<span class="built_in">Array</span>.prototype.split = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">this</span>.slice(<span class="number">0</span>,i), <span class="keyword">this</span>.slice(i)];</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>使用猴子补丁为缺失的API提供polyfills.</p></li></ol><hr><h4 id="数组和字典"><a href="#数组和字典" class="headerlink" title="数组和字典"></a>数组和字典</h4><h5 id="43-使用Object的直接实例构造轻量级的字典"><a href="#43-使用Object的直接实例构造轻量级的字典" class="headerlink" title="43 - 使用Object的直接实例构造轻量级的字典"></a>43 - 使用Object的直接实例构造轻量级的字典</h5><p>轻量级字典的<strong>首要原则</strong>: 使用Object的直接实例作为字典,而不是其子类或者数组.这样不容易遇到原型污染的问题(因为原型污染的范围缩小到仅有Object.prototype).并且我们本身也建议不要直接添加属性到Object.prototype中.</p><p>使用for…in循环去枚举字典的属性.</p><h5 id="44-使用null原型以防止原型污染"><a href="#44-使用null原型以防止原型污染" class="headerlink" title="44 - 使用null原型以防止原型污染"></a>44 - 使用null原型以防止原型污染</h5><p>防止原型污染最简单的方式之一就是一开始就不使用原型.</p><p>ES5:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(o) === <span class="literal">null</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>存在的问题:</strong></p><ol><li><p>在不同环境中,还是会有一些问题.</p><p>理想中,空对象是不存在__proto__属性的. in和hasOwnProperty都应该返回false</p><blockquote><p>而在一些环境中(只有in操作符为true)</p><p>“xxx” in o //true</p><p>{}.hasOwnProperty.call(o, “_<em>proto_</em>“) //false</p><p>而在一些环境中,会存在一个实例属性_<em>proto_</em></p><p>“xxx” in o //true</p><p>{}.hasOwnProperty.call(o, “_<em>proto_</em>“) //true</p></blockquote></li></ol><p>ES5前不支持Object.create函数的环境:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">__proto__</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>存在的问题:</strong></p><ol><li>__proto__既不标准,也不是完全可移植的,并且在未来可能被移除</li><li>如果使用__proto__作为属性名,可能会导致一些问题,因为一些环境中把他作为特殊的属性对待.</li></ol><p><strong>=&gt;推荐45中的方式定义字典.</strong></p><h5 id="45-使用hasOwnProperty方法避免原型污染"><a href="#45-使用hasOwnProperty方法避免原型污染" class="headerlink" title="45 - 使用hasOwnProperty方法避免原型污染"></a>45 - 使用hasOwnProperty方法避免原型污染</h5><p>一种避免原型污染的字典的有效实践</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了达到最大的可移植性和安全性,对__proto__属性做了特殊处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dict</span>(<span class="params">elements</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elements = elements || &#123;&#125;;</span><br><span class="line">    <span class="comment">//是否设置了__proto__属性的标识符</span></span><br><span class="line">    <span class="keyword">this</span>.hasSpecialProto = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//用于存储设置的__proto__的值</span></span><br><span class="line">    <span class="keyword">this</span>.specialProto = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line">Dict.prototype.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key === <span class="string">"__proto__"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hasSpecialProto;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用&#123;&#125;.hasOwnProperty的方式,避免原型污染</span></span><br><span class="line">    <span class="comment">//普通的类,很可能因为原型定义了hasOwnProperty的方法导致原型污染</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;.hasOwnProperty.call(<span class="keyword">this</span>.elements, key);</span><br><span class="line">&#125;</span><br><span class="line">Dict.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key === <span class="string">"__proto__"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.specialProto;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? <span class="keyword">this</span>.elements[key] : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line">Dict.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key === <span class="string">"__proto__"</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasSpecialProto = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.specialProto = val;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dict.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key === <span class="string">"__proto__"</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasSpecialProto = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.specialProto = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.elements[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="46-使用数组而不要使用字典来存储-有序-集合"><a href="#46-使用数组而不要使用字典来存储-有序-集合" class="headerlink" title="46 - 使用数组而不要使用字典来存储 有序 集合"></a>46 - 使用数组而不要使用字典来存储 有序 集合</h5><p><strong>原因:</strong> JavaScript对象是一个无序的属性集合,获得和设置不同的属性与顺序无关,与js引擎有关.</p><p><strong>tips:</strong></p><ol><li>使用for…in循环来枚举对象的属性应当与顺序无关</li><li>如果聚集运算字典中的数据,确保聚集操作与顺序无关(其实也就是<strong>不要用字典来存储有序的数据</strong>)</li><li>使用数组而不是字典来存储有序集合</li></ol><h5 id="47-绝不要在Object-prototype中增加可枚举的属性"><a href="#47-绝不要在Object-prototype中增加可枚举的属性" class="headerlink" title="47 - 绝不要在Object.prototype中增加可枚举的属性"></a>47 - 绝不要在Object.prototype中增加可枚举的属性</h5><p><strong>原因:</strong>在Object.prototype中添加可枚举的属性,会污染所有字典的枚举遍历.所以避免在Object.prototype中增加属性</p><p>折中方式:</p><ol><li><p>考虑编写一个函数代替Object.prototype</p><blockquote><p>对象中的函数就叫做方法,通过”.”的方式调用</p></blockquote></li><li><p>ES5后提供的方法,定义不可枚举的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">"allKeys"</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">            result.push(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,<span class="comment">//这一项就是定义allKeys是不可枚举的,for...in时不会出现它</span></span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h5 id="48-避免在枚举期间修改对象"><a href="#48-避免在枚举期间修改对象" class="headerlink" title="48 - 避免在枚举期间修改对象"></a>48 - 避免在枚举期间修改对象</h5><p><strong>原因:</strong>for…in遍历枚举的期间,添加新的属性,不能保证在枚举期间能访问到新添加的属性.</p><p><strong>tips:</strong></p><ol><li>使用for…in循环枚举一个对象的属性时,确保不要修改该对象.</li><li>迭代一个对象时,如果对象的内容在循环期间可能会改变,应该用while循环或经典for循环来代替for…in 循环.</li><li>为了在不断变化的数据结构中能够预测枚举,考虑使用一个有序的数据结构,如数组,而不是字典对象.</li></ol><h5 id="49-数组迭代要优先使用for循环而不是for…in循环"><a href="#49-数组迭代要优先使用for循环而不是for…in循环" class="headerlink" title="49 - 数组迭代要优先使用for循环而不是for…in循环"></a>49 - 数组迭代要优先使用for循环而不是for…in循环</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="number">98</span>,<span class="number">74</span>,<span class="number">85</span>,<span class="number">77</span>,<span class="number">93</span>,<span class="number">100</span>,<span class="number">89</span>];</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> score <span class="keyword">in</span> scores)&#123;</span><br><span class="line">	total += score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mean = total / scores.length;<span class="comment">//此时的total其实是00123456</span></span><br><span class="line"><span class="built_in">console</span>.log(mean);<span class="comment">//17636.571428571428而不是88</span></span><br><span class="line"><span class="comment">//正确的操作方式</span></span><br><span class="line"><span class="comment">//且在一开始就计算出数组的长度,避免写在中间,那样每次迭代都会计算一次数组长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = scores.length; i &lt; n; i++)&#123;</span><br><span class="line">    total += scores[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="50-迭代方法优于循环"><a href="#50-迭代方法优于循环" class="headerlink" title="50 - 迭代方法优于循环"></a>50 - 迭代方法优于循环</h5><p><strong>原因:</strong>常见的终止条件的错误.</p><p><strong>循环</strong>相对于迭代函数<strong>的唯一优势</strong>: <strong>有控制流操作</strong>,如break和continue.</p><p>如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;...&#125;<span class="comment">//尾部多了一次循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;...&#125;<span class="comment">//头部少了第一次循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = n; i &gt;= <span class="number">0</span>; i--)&#123;...&#125;<span class="comment">//多了头部的一次循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;...&#125;<span class="comment">//少了最后一次循环</span></span><br></pre></td></tr></table></figure><p>常用模式1:<strong>Array.prototype.forEach</strong></p><p>代码简单可读并且消除了终止条件和任何数组索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = players.length; i &lt; n; i++)&#123;</span><br><span class="line">    players[i].score++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">players.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">    p.score++;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>常用模式2: <strong>Array.prototype.map</strong></p><p>对数组每个元素进行一些操作后建立一个新的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trimmed = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = input.length; i &lt; n; i ++)&#123;</span><br><span class="line">    trimmed.push(input[i].trim());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">var</span> trimmed = input.map(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>常用模式3:<strong>Array.prototype.filter</strong></p><p>计算一个新的数组,数组中的元素为现有数组中的一部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = listings.filter(<span class="function"><span class="keyword">function</span>(<span class="params">listing</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listing.price &gt;= min &amp;&amp; listing.price &lt;= max;<span class="comment">//return true的值会被留下,返回false的就不存在返回的新数组中了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以提前终止循环的模式:</p><p><strong>Array.prototype.some</strong></p><p>返回一个布尔值表示其回调函数对数组的<strong>任何一个</strong>元素是否返回了真值</p><p><strong>一旦产生真值就返回</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x &gt; <span class="number">5</span>;&#125;);<span class="comment">//true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span>;&#125;);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>Array.prototype.every</strong></p><p>返回一个布尔值表示其回调函数是否对<strong>所有</strong>元素返回了一个真值</p><p><strong>一旦产生假值就返回</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x &gt; <span class="number">0</span>;&#125;); <span class="comment">//true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x &lt; <span class="number">3</span>;&#125;); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><ol><li>使用迭代方法替换for循环增加代码可读性,避免思考重复循环的逻辑控制(即边界条件)</li><li>使用自定义迭代函数来抽象常见循环模式(注意猴子补丁的注意事项,见42)</li><li>在存在需要提前终止的情况下,仍推荐传统的循环方式,避免不必要的循环.另外,some和every也可用于提前退出.</li></ol><h5 id="51-在类数组对象上复用通用的数组方法"><a href="#51-在类数组对象上复用通用的数组方法" class="headerlink" title="51 - 在类数组对象上复用通用的数组方法"></a>51 - 在类数组对象上复用通用的数组方法</h5><p><strong>类数组对象的规则:</strong></p><ol><li>具有一个范围在0~2^32-1的整型length属性</li><li>length属性大于该对象的最大索引.索引是一个范围在0~2^32-2的整数,它的字符串表示的是该对象中的一个key</li></ol><p><strong>满足上述两个条件的类数组对象使用Array.prototype任一方法都可兼容(除了concat方法必须是数组对象才行).</strong></p><p>使用方式:</p><p>[].(forEach/some/…).call(类数组对象, …);</p><p><strong>常见类数组</strong></p><ol><li>函数的arguments对象</li><li>DOM的NodeList类,如:document.getElementsByTagName,document.querySelectorAll获得的对象</li><li>自定义的简单对象字面量 如:var arrayLike = {0: “a”,1:”b”,2:”c”,length:3};</li><li>字符串</li></ol><p><strong>转换类数组为真正的数组对象的方法</strong></p><ol><li>[].slice.call(类数组对象)</li><li>Array.from(类数组对象/可迭代对象Set,Map)</li></ol><h5 id="52-数组字面量优于数组构造函数"><a href="#52-数组字面量优于数组构造函数" class="headerlink" title="52 - 数组字面量优于数组构造函数"></a>52 - 数组字面量优于数组构造函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//优于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>好处:</strong></p><ol><li>使用构造函数的方式需要先确认Array没被包装过</li><li>使用构造函数的方式需要确认没人修改过全局的Array变量</li></ol><p>//以上两点应该不太可能发生…</p><ol start="3"><li><p>使用单个数组时,有明显不同</p><blockquote><p>var a = [17];和var a = new Array(17);</p><p>后者会创建一个17长度的数组!</p></blockquote></li></ol><hr><h4 id="库和API设计"><a href="#库和API设计" class="headerlink" title="库和API设计"></a>库和API设计</h4><h5 id="53-保持一致的约定"><a href="#53-保持一致的约定" class="headerlink" title="53 - 保持一致的约定"></a>53 - 保持一致的约定</h5><p><strong>tips:</strong></p><ol><li>在变量命名和函数签名中使用一致的约定.如width,height等</li><li>不要偏移用户在他们开发平台中很可能遇到的约定.如width,height的顺序等等</li></ol><h5 id="54-将undefined看做”没有值”-缺少某个特定的值"><a href="#54-将undefined看做”没有值”-缺少某个特定的值" class="headerlink" title="54 - 将undefined看做”没有值”(缺少某个特定的值)"></a>54 - 将undefined看做”没有值”(缺少某个特定的值)</h5><p><strong>出现undefined的情况</strong></p><ol><li>未赋值的变量初始值为undefined</li><li>访问对象中不存在的属性,会产生undefined</li><li>函数体尾使用未带参数的return ;或者<strong>未使用return都会产生返回值undefined</strong></li><li>未给函数提供实参则该函数参数值为undefined</li></ol><p><strong>可选参数的实现的常见做法</strong>(不要检查arguments.length,下面两种方式更健壮)</p><ol><li><p>测试undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Server</span>(<span class="params">port, hostname</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hostname === <span class="literal">undefined</span>)&#123;</span><br><span class="line">        hostname = <span class="string">"localhost"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hostname = <span class="built_in">String</span>(hostname);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试是否为真</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Server</span>(<span class="params">Port, hostname</span>)</span>&#123;</span><br><span class="line">    hostname = <span class="built_in">String</span>(hostname || <span class="string">"localhost"</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑运算符或(||),当第一个参数为真时返回第一个参数,否则返回第二个参数</p><p>不适合使用”测试是否为真”的情况是:</p><p>​ 如果除了undefined的其他假值(false, 0, -0, null, NaN, “”)可以为函数的合法值时,就不能使用这种方式.需要选用上一种方式</p></li></ol><h5 id="55-接收关键字参数的选项对象"><a href="#55-接收关键字参数的选项对象" class="headerlink" title="55 - 接收关键字参数的选项对象"></a>55 - 接收关键字参数的选项对象</h5><p><strong>tips:</strong></p><ol><li><p>使用选项对象使得API更具可读性、更容易记忆;且参数都是可选的,调用者可提供任一可选参数的子集.</p><ul><li>原因: 当参数过多时,位置参数的方式可读性很差</li></ul></li><li><p>所有通过选项对象提供的参数应当被视为可选的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Alert</span>(<span class="params">parent, message, opts</span>)</span>&#123;<span class="comment">//必选的parent和message需要抽离出来</span></span><br><span class="line">    opts = opts || &#123;&#125;;<span class="comment">//如果不传入,初始化一个空对象避免后面的操作报错</span></span><br><span class="line">    <span class="keyword">this</span>.width = opts.width == <span class="literal">undefined</span> ? <span class="number">320</span>: opts.width;<span class="comment">//数字参数 0一般是合法值,所以要用undefined判断</span></span><br><span class="line">    <span class="keyword">this</span>.height = opts.height == <span class="literal">undefined</span> ? <span class="number">240</span>: opts.height;</span><br><span class="line">    <span class="keyword">this</span>.title = opts.title || <span class="string">"Alert"</span>;<span class="comment">//字符串一般空串不会算作合法值,所以这里用或操作符,如果此处空串也为合法值,那应该改为测试undefined</span></span><br><span class="line">    <span class="keyword">this</span>.modal = !!opts.modal;<span class="comment">//布尔值,使用双重否定将参数强制转换成一个布尔值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果使用其他库,可以使用extend函数抽象出从选项对象中提取值的逻辑(前提是库/框架提供了这个函数)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个典型的extend实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">            <span class="keyword">var</span> val = source[key];</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> val !== <span class="string">"undefined"</span>)&#123;</span><br><span class="line">                target[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经过extend函数简化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Alert</span>(<span class="params">parent, message, opts</span>)</span>&#123;</span><br><span class="line">    opts = extend(&#123;</span><br><span class="line">        width:<span class="number">320</span>,</span><br><span class="line">        height:<span class="number">240</span></span><br><span class="line">    &#125;);</span><br><span class="line">    opts = extend(&#123;</span><br><span class="line">        title: <span class="string">"Alert"</span>,</span><br><span class="line">        modal: <span class="literal">false</span></span><br><span class="line">    &#125;, opts);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.width = opts.width;</span><br><span class="line">    <span class="keyword">this</span>.height = opts.height;</span><br><span class="line">    <span class="keyword">this</span>.title = opts.title;</span><br><span class="line">    <span class="keyword">this</span>.modal = opts.modal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果options是整个复制到this对象,可以进一步简化上面四行</span></span><br><span class="line">    extend(<span class="keyword">this</span>, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="56-避免不必要的状态-状态有时候是必须的"><a href="#56-避免不必要的状态-状态有时候是必须的" class="headerlink" title="56 - 避免不必要的状态(状态有时候是必须的)"></a>56 - 避免不必要的状态(状态有时候是必须的)</h5><p>区别:无状态函数或方法的行为只取决于输入,与程序的状态改变无关</p><p>好处: 更容易学习和使用,更清晰(简洁),更不易出错; 相比于有状态的API,无状态的API会自动重用默认值,我们就不用担心默认值是否在前面某处被更改了.</p><p><strong>tips:</strong></p><ol><li>尽可能地使用无状态的API</li><li>如果API是有状态的,需要标示出每个操作与哪些状态有关联</li></ol><h5 id="57-使用结构类型structural-typing-鸭子类型duck-typing-设计灵活的接口"><a href="#57-使用结构类型structural-typing-鸭子类型duck-typing-设计灵活的接口" class="headerlink" title="57 - 使用结构类型structural typing(鸭子类型duck typing)设计灵活的接口"></a>57 - 使用结构类型structural typing(鸭子类型duck typing)设计灵活的接口</h5><p>区别于一般面向对象语言推荐的使用类和继承来结构化程序, javaScript动态类型使用的方式更灵活.只要有预期的结构即可.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Wiki.formats.MEDIAWIKI = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//extract contents from source</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getTitle: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* ... */</span>&#125;,</span><br><span class="line">        getAuthor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* ... */</span>&#125;,</span><br><span class="line">        toHTML: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们完全可以根据每种格式的需要,混合和匹配功能</strong></p><p>继承有时候导致比他解决的问题外更多的问题.</p><blockquote><p>静态语言迫使必须符合某个数据类型,增加了更多的代码;而动态语言可以编写更少的代码,使代码更简洁,可以花更多的精力在业务逻辑上.缺点是无法保证变量类型,可能在运行时出错.</p><p>鸭子类型是典型的面向接口编程,且不必借助超类的帮助.它只要正确的实现了我们需要的方法供我们调用即可.</p></blockquote><p><strong>tips:</strong></p><ol><li>使用结构类型来设计灵活的对象接口</li><li>结构接口更灵活,更轻量,所以应该避免使用继承</li><li>针对单元测试,使用mock对象即接口的替代实现来提供可复验的行为.</li></ol><h5 id="58-区分数组对象和类数组对象"><a href="#58-区分数组对象和类数组对象" class="headerlink" title="58 - 区分数组对象和类数组对象"></a>58 - 区分数组对象和类数组对象</h5><p><strong>tips:</strong></p><ol><li>绝不重载与其他类型有重叠的结构类型</li><li>当重载一个结构类型与其他类型时,先测试其他类型.因为结构类型没有明确的信息标记他们实现的结构类型,没有可靠的编程方法来检测该信息.</li><li>当重载其他对象类型时,接受真数组而不是类数组对象</li><li>文档标注你的API是否接受真数组或类数组值</li><li>使用ES5提供的Array.isArray方法测试真数组(比instance of操作符更可靠)</li></ol><h5 id="59-避免过度的强制转换"><a href="#59-避免过度的强制转换" class="headerlink" title="59 - 避免过度的强制转换"></a>59 - 避免过度的强制转换</h5><p><strong>tips:</strong></p><ol><li>避免强制转换和重载混用</li><li>考虑防御性地监视非预期的输入<ul><li>防御性编程:试图以额外的检查来抵御潜在的错误</li></ul></li></ol><h5 id="60-支持方法链-就是函数式编程"><a href="#60-支持方法链-就是函数式编程" class="headerlink" title="60 - 支持方法链(就是函数式编程)"></a>60 - 支持方法链(就是函数式编程)</h5><p><strong>tips:</strong></p><ol><li>使用方法链来连接无状态的操作.</li><li>通过在无状态的方法中返回新对象来支持方法链</li><li>通过在有状态的方法中返回this来支持方法链</li></ol><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><hr><h5 id="61-不要阻塞I-O事件队列"><a href="#61-不要阻塞I-O事件队列" class="headerlink" title="61 - 不要阻塞I/O事件队列"></a>61 - 不要阻塞I/O事件队列</h5><p>系统维护了一个按事件发生顺序排列的内部事件队列,一次调用一个已注册的回调函数,在执行过程中,系统会适时地查看处理进度,会在异步执行结束后立刻调用回调函数.</p><p><strong>好处:</strong>系统的这种运行方式有时被称为<strong>运行到完成机制担保</strong>(run-to-completion),当代码运行时,你完全可以掌握应用程序的状态,不用担心一些变量和对象的属性由于并发执行代码而超出你的控制.</p><p><strong>不足:</strong>实际上这些异步执行的代码支撑着后续应用程序的执行(返回某些重要的参数,又会作为后面代码的实参等等).在客户端,一个阻塞的事件处理程序会阻塞任何将被处理的其他用户输入,甚至阻塞页面渲染;在服务器端,一个阻塞的事件处理程序可能会阻塞其他将被处理的网络请求,导致服务器失去响应.</p><p><strong>tips:</strong></p><ol><li>异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序.</li><li>JavaScript并发地接收事件,但会使用一个事件队列按序地处理事件.</li><li>在应用程序事件队列中绝不要使用阻塞的I/O.</li></ol><h5 id="62-在异步序列中使用嵌套或命名的回调函数"><a href="#62-在异步序列中使用嵌套或命名的回调函数" class="headerlink" title="62 - 在异步序列中使用嵌套或命名的回调函数"></a>62 - 在异步序列中使用嵌套或命名的回调函数</h5><p>为了保证存在依赖的异步代码的执行顺序,使用嵌套或命名的回调函数.</p><p><strong>tips:</strong></p><ol><li><p>使用嵌套或命名的回调函数按顺序地执行多个异步操作.</p></li><li><p>尝试在过多的嵌套的回调函数和尴尬的命名的非嵌套回调函数中取得平衡(<strong>后面会介绍解决该问题的ES6新特性Promise</strong>)</p></li><li><p>避免将可被并行执行的操作顺序化.</p></li></ol><h5 id="63-当心丢弃错误"><a href="#63-当心丢弃错误" class="headerlink" title="63 - 当心丢弃错误"></a>63 - 当心丢弃错误</h5><p>常见的异步处理错误:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个附加的错误处理回调函数(errbacks)</span></span><br><span class="line">downloadAsync(<span class="string">"http://example.com/file.txt"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Error:"</span> + error);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2.异步操作出错则回调函数返回的第一个参数为真,没出错则为一个假值</span></span><br><span class="line"><span class="comment">//常用在Node.js平台</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Error:"</span> + error);</span><br><span class="line">&#125;</span><br><span class="line">downloadAsync(<span class="string">"a.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error) <span class="keyword">return</span> onError(error);</span><br><span class="line">    downloadAsync(<span class="string">"b.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(error) <span class="keyword">return</span> onError(error);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"contents:"</span> + a + b);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><ol><li>通过编写共享的错误处理函数来避免赋值和粘贴错误处理代码</li><li>确保明确地处理所有的错误条件以避免丢失错误.</li></ol><h5 id="64-对异步循环使用递归"><a href="#64-对异步循环使用递归" class="headerlink" title="64 - 对异步循环使用递归"></a>64 - 对异步循环使用递归</h5><p><strong>tips:</strong></p><ol><li>循环不能是异步的.</li><li>使用递归函数在事件循环的单独轮次中执行迭代.</li><li>在事件循环的单独轮次中执行递归,并不会导致调用栈溢出.</li></ol><h5 id="65-不要在计算时阻塞事件队列"><a href="#65-不要在计算时阻塞事件队列" class="headerlink" title="65 - 不要在计算时阻塞事件队列"></a>65 - 不要在计算时阻塞事件队列</h5><p><strong>tips:</strong></p><ol><li>避免在主事件队列中执行代价高昂的算法. (如:使用setTimeout的方式变为异步执行)</li><li>在支持Worker API 的平台, 该API可以用在一个独立的事件队列中运行长计算程序.</li><li>在Worker API不可用或代价昂贵的环境中, 考虑将计算程序分解到事件循环的多个轮次中.</li></ol><h5 id="66-使用计数器来执行并行操作"><a href="#66-使用计数器来执行并行操作" class="headerlink" title="66 - 使用计数器来执行并行操作"></a>66 - 使用计数器来执行并行操作</h5><p><strong>tips:</strong></p><ol><li>并行操作的结果顺序是不可预测的,这个时候我们可以使用计算器去确定代码的执行进度.</li></ol><h5 id="67-绝不要同步地调用异步的回调函数"><a href="#67-绝不要同步地调用异步的回调函数" class="headerlink" title="67 - 绝不要同步地调用异步的回调函数"></a>67 - 绝不要同步地调用异步的回调函数</h5><p>举例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方代码</span></span><br><span class="line">downloadCachingAsync(<span class="string">"file.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"finished"</span>);<span class="comment">//might happen first</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"starting"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//被调用方,定义的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadCachingAsync</span>(<span class="params">url, onsuccess, onerror</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache.has(url))&#123;<span class="comment">//模拟有缓存的情况,这种情况代码走到了同步回调中</span></span><br><span class="line">        onsuccess(cache.get(url));<span class="comment">//此处同步调用了回调!!!</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//正确的做法</span></span><br><span class="line">        <span class="comment">//return setTimeout(onsuccess(cache.get(url),0));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> downloadAsync(url, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">        cache.set(url, file);</span><br><span class="line">        onsuccess(file);</span><br><span class="line">    &#125;, onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在的问题:</p><ol><li>如上述代码, 同步的调用异步的回调函数,导致日志消息竟然出现了错误的顺序(“finish”先于”starting”)</li><li>如64条所述, 异步回调本质上以空的调用栈来调用, 因此异步的循环实现为递归函数时安全的.但是如果同步地调用不能保障这一点,会使得表面上是异步的循环耗尽栈空间.</li></ol><p><strong>tips:</strong></p><ol><li>即使可以立即得到数据,也绝不要同步地调用异步回调函数</li><li>同步地调用异步回调函数扰乱了操作的序列,可能导致意想不到的交错代码</li><li>同步地调用异步的回调可能导致栈溢出或错误地处理异常</li><li>使用异步的API.如setTimeout函数异步回调函数</li></ol><h5 id="68-使用promise模式清洁异步逻辑"><a href="#68-使用promise模式清洁异步逻辑" class="headerlink" title="68 - 使用promise模式清洁异步逻辑"></a>68 - 使用promise模式清洁异步逻辑</h5><p>基于promise的API不接收回调函数作为参数,而是返回一个promise对象,通过自身的then方法接收回调函数.</p><p><strong>tips:</strong></p><ol><li>promise代表最终值,即并行操作完成时最终产生的结果.</li><li>使用promise组合不同的并行操作</li><li>使用promise模式的API避免数据竞争</li><li>在要求有意的竞争条件时使用select(也被称为choose)</li></ol></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束,如有斧正请邮件kur1kosheng@gmail.com-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-javaScript/" rel="tag"><i class="fa fa-tag"></i> 读书笔记,javaScript</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/04/01/%E4%BB%8E%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E8%AE%B2%E9%81%8D%E5%8E%86/" rel="next" title="从遍历方式讲遍历"><i class="fa fa-chevron-left"></i> 从遍历方式讲遍历</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/image.jpg" alt="kur1ko Sheng"><p class="site-author-name" itemprop="name">kur1ko Sheng</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kur1ko" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Effective-JavaScript"><span class="nav-number">1.</span> <span class="nav-text">Effective JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#让自己习惯javaScript"><span class="nav-number">1.0.1.</span> <span class="nav-text">让自己习惯javaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-了解你使用的javaScript版本"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">1 - 了解你使用的javaScript版本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-理解javaScript浮点数"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">2 - 理解javaScript浮点数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-当心隐式类型转换"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">3 - 当心隐式类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-原始类型优于封装对象"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">4 - 原始类型优于封装对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-避免对混合类型使用-运算符"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">5 - 避免对混合类型使用 &#x3D;&#x3D; 运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-了解分号插入的局限"><span class="nav-number">1.0.1.6.</span> <span class="nav-text">6 - 了解分号插入的局限</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-视字符串为16位的代码单元序列"><span class="nav-number">1.0.1.7.</span> <span class="nav-text">7 - 视字符串为16位的代码单元序列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量作用域"><span class="nav-number">1.0.2.</span> <span class="nav-text">变量作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-尽量少用全局变量"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">8 - 尽量少用全局变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-始终声明局部变量"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">9 - 始终声明局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-避免使用with"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">10 - 避免使用with</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-熟练掌握闭包"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">11 - 熟练掌握闭包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-理解变量声明提升"><span class="nav-number">1.0.2.5.</span> <span class="nav-text">12 - 理解变量声明提升</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-使用立即调用的函数表达式创建局部作用域"><span class="nav-number">1.0.2.6.</span> <span class="nav-text">13 - 使用立即调用的函数表达式创建局部作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-当心命名函数表达式笨拙的作用域"><span class="nav-number">1.0.2.7.</span> <span class="nav-text">14 - 当心命名函数表达式笨拙的作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15-当心局部块函数声明笨拙的作用域"><span class="nav-number">1.0.2.8.</span> <span class="nav-text">15 - 当心局部块函数声明笨拙的作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#16-避免使用eval创建局部变量"><span class="nav-number">1.0.2.9.</span> <span class="nav-text">16 - 避免使用eval创建局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remain-learning-17-间接调用eval函数优于直接调用"><span class="nav-number">1.0.2.10.</span> <span class="nav-text">(remain learning)17 - 间接调用eval函数优于直接调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用函数"><span class="nav-number">1.0.3.</span> <span class="nav-text">使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#18-理解函数调用、方法调用及构造函数调用之间的不同"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">18 - 理解函数调用、方法调用及构造函数调用之间的不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-熟练掌握高阶函数"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">19 - 熟练掌握高阶函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-使用call方法自定义接收者来调用方法"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">20 - 使用call方法自定义接收者来调用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#call-apply-bind"><span class="nav-number">1.0.3.3.1.</span> <span class="nav-text">call, apply, bind</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#21-使用apply-方法通过不同数量的参数调用函数"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">21- 使用apply 方法通过不同数量的参数调用函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#22-使用arguments创建可变参数的函数"><span class="nav-number">1.0.3.5.</span> <span class="nav-text">22 - 使用arguments创建可变参数的函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#23-永远不要修改arguments对象"><span class="nav-number">1.0.3.6.</span> <span class="nav-text">23 - 永远不要修改arguments对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#24-使用变量保存arguments的引用"><span class="nav-number">1.0.3.7.</span> <span class="nav-text">24 - 使用变量保存arguments的引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#25-使用bind方法提取具有确定接收者的方法"><span class="nav-number">1.0.3.8.</span> <span class="nav-text">25 - 使用bind方法提取具有确定接收者的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#26-使用bind方法实现函数柯里化"><span class="nav-number">1.0.3.9.</span> <span class="nav-text">26 - 使用bind方法实现函数柯里化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#27-使用闭包而不是字符串来封装代码-现在ES6有块级作用域了-感觉答案更显而易见了"><span class="nav-number">1.0.3.10.</span> <span class="nav-text">27 - 使用闭包而不是字符串来封装代码(?现在ES6有块级作用域了,感觉答案更显而易见了?)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#28-不要信赖函数对象的toString方法"><span class="nav-number">1.0.3.11.</span> <span class="nav-text">28 - 不要信赖函数对象的toString方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remain-learning-29-避免使用非标准的栈检查属性"><span class="nav-number">1.0.3.12.</span> <span class="nav-text">(remain learning)29 - 避免使用非标准的栈检查属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象和原型"><span class="nav-number">1.0.4.</span> <span class="nav-text">对象和原型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#30-理解prototype-getPrototypeOf和-proto-之间的不同"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">30 - 理解prototype, getPrototypeOf和__proto__之间的不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#31-使用Object-getPrototypeOf函数-而不要使用-proto-属性"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">31 - 使用Object.getPrototypeOf函数,而不要使用__proto__属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#32-始终不要修改-proto-属性"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">32 - 始终不要修改__proto__属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#33-使构造函数与new操作符无关-ES6引入了class-这部分内容应该过时了"><span class="nav-number">1.0.4.4.</span> <span class="nav-text">33 - 使构造函数与new操作符无关(ES6引入了class,这部分内容应该过时了)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#34-在原型中存储方法"><span class="nav-number">1.0.4.5.</span> <span class="nav-text">34 - 在原型中存储方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#35-使用闭包存储私有数据"><span class="nav-number">1.0.4.6.</span> <span class="nav-text">35 - 使用闭包存储私有数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#36-只将实例状态存储在实例对象中"><span class="nav-number">1.0.4.7.</span> <span class="nav-text">36 - 只将实例状态存储在实例对象中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#37-认识到this变量的隐式绑定问题"><span class="nav-number">1.0.4.8.</span> <span class="nav-text">37 - 认识到this变量的隐式绑定问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#38-在子类的构造函数中调用父类的构造函数-ES6引入了class-这部分内容应该过时了"><span class="nav-number">1.0.4.9.</span> <span class="nav-text">38 - 在子类的构造函数中调用父类的构造函数(ES6引入了class,这部分内容应该过时了)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#39-不要重用父类的属性名"><span class="nav-number">1.0.4.10.</span> <span class="nav-text">39 - 不要重用父类的属性名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#40-避免继承标准类"><span class="nav-number">1.0.4.11.</span> <span class="nav-text">40 - 避免继承标准类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#41-将原型视为实现细节"><span class="nav-number">1.0.4.12.</span> <span class="nav-text">41 - 将原型视为实现细节</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#42-避免使用轻率的猴子补丁"><span class="nav-number">1.0.4.13.</span> <span class="nav-text">42 - 避免使用轻率的猴子补丁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组和字典"><span class="nav-number">1.0.5.</span> <span class="nav-text">数组和字典</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#43-使用Object的直接实例构造轻量级的字典"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">43 - 使用Object的直接实例构造轻量级的字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#44-使用null原型以防止原型污染"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">44 - 使用null原型以防止原型污染</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#45-使用hasOwnProperty方法避免原型污染"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">45 - 使用hasOwnProperty方法避免原型污染</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#46-使用数组而不要使用字典来存储-有序-集合"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">46 - 使用数组而不要使用字典来存储 有序 集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#47-绝不要在Object-prototype中增加可枚举的属性"><span class="nav-number">1.0.5.5.</span> <span class="nav-text">47 - 绝不要在Object.prototype中增加可枚举的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#48-避免在枚举期间修改对象"><span class="nav-number">1.0.5.6.</span> <span class="nav-text">48 - 避免在枚举期间修改对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#49-数组迭代要优先使用for循环而不是for…in循环"><span class="nav-number">1.0.5.7.</span> <span class="nav-text">49 - 数组迭代要优先使用for循环而不是for…in循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#50-迭代方法优于循环"><span class="nav-number">1.0.5.8.</span> <span class="nav-text">50 - 迭代方法优于循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#51-在类数组对象上复用通用的数组方法"><span class="nav-number">1.0.5.9.</span> <span class="nav-text">51 - 在类数组对象上复用通用的数组方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#52-数组字面量优于数组构造函数"><span class="nav-number">1.0.5.10.</span> <span class="nav-text">52 - 数组字面量优于数组构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#库和API设计"><span class="nav-number">1.0.6.</span> <span class="nav-text">库和API设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#53-保持一致的约定"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">53 - 保持一致的约定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#54-将undefined看做”没有值”-缺少某个特定的值"><span class="nav-number">1.0.6.2.</span> <span class="nav-text">54 - 将undefined看做”没有值”(缺少某个特定的值)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#55-接收关键字参数的选项对象"><span class="nav-number">1.0.6.3.</span> <span class="nav-text">55 - 接收关键字参数的选项对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#56-避免不必要的状态-状态有时候是必须的"><span class="nav-number">1.0.6.4.</span> <span class="nav-text">56 - 避免不必要的状态(状态有时候是必须的)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#57-使用结构类型structural-typing-鸭子类型duck-typing-设计灵活的接口"><span class="nav-number">1.0.6.5.</span> <span class="nav-text">57 - 使用结构类型structural typing(鸭子类型duck typing)设计灵活的接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#58-区分数组对象和类数组对象"><span class="nav-number">1.0.6.6.</span> <span class="nav-text">58 - 区分数组对象和类数组对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#59-避免过度的强制转换"><span class="nav-number">1.0.6.7.</span> <span class="nav-text">59 - 避免过度的强制转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#60-支持方法链-就是函数式编程"><span class="nav-number">1.0.6.8.</span> <span class="nav-text">60 - 支持方法链(就是函数式编程)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发"><span class="nav-number">1.0.7.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#61-不要阻塞I-O事件队列"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">61 - 不要阻塞I&#x2F;O事件队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#62-在异步序列中使用嵌套或命名的回调函数"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">62 - 在异步序列中使用嵌套或命名的回调函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#63-当心丢弃错误"><span class="nav-number">1.0.7.3.</span> <span class="nav-text">63 - 当心丢弃错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#64-对异步循环使用递归"><span class="nav-number">1.0.7.4.</span> <span class="nav-text">64 - 对异步循环使用递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#65-不要在计算时阻塞事件队列"><span class="nav-number">1.0.7.5.</span> <span class="nav-text">65 - 不要在计算时阻塞事件队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#66-使用计数器来执行并行操作"><span class="nav-number">1.0.7.6.</span> <span class="nav-text">66 - 使用计数器来执行并行操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#67-绝不要同步地调用异步的回调函数"><span class="nav-number">1.0.7.7.</span> <span class="nav-text">67 - 绝不要同步地调用异步的回调函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#68-使用promise模式清洁异步逻辑"><span class="nav-number">1.0.7.8.</span> <span class="nav-text">68 - 使用promise模式清洁异步逻辑</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">kur1ko Sheng</span></div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共16.7k字</span></div><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span>次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html>